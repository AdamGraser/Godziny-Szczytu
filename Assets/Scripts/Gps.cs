//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.269
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

// Reprezentuje nawigacje "zwyklego" agenta
public class Gps
{
	// Mapa, po ktorej porusza sie agent
	protected Map MyMap;
	
	// Akcesor do mapy (agent inteligentny bedzie w tej funkcji robil cos wiecej.
	public virtual void LoadMap(Map mapToLoad)
	{
		MyMap = mapToLoad;
	}
	
	// Wyszukuje najkrotsza sciezke uzywajac algorytmy Dijikstry
	public virtual List<Vector2> FindPath(Vector2 start, Vector2 end)
	{
		// Przygotowanie odpowiednich tablic		
		List<Vector2> crossings = MyMap.GetAllCrossroads();
		int numberOfCrossings = crossings.Count;
		int max = int.MaxValue;
		
		Vector2[] crossingsTable = new Vector2[numberOfCrossings]; // Indeksy wezlow
		float[] distance = new float[numberOfCrossings]; // Odleglosc do wezla
		int[] previousCrossing = new int[numberOfCrossings]; // Indeks poprzednika
		bool[] flags = new bool[numberOfCrossings];
		
		int i;
		for (i = 0; i < numberOfCrossings; ++i)
		{
			crossingsTable[i] = crossings[i];
			
			if ((crossings[i] == start))
			{
				distance[i] = 0;
			}
			else
			{
				distance[i] = max; // nieskonczonosc
			}
			
			previousCrossing[i] = i; // niezdefiniowany (sam dla siebie)
			flags[i] = false;
		}
		
		int j, current, neighbour;
		float currentDistance;
		
		// Wlasciwy algorytm //
		
		for (i = 0; i < numberOfCrossings; ++i) // Proces trzeba powtorzyc tyle razy, ile jest wezlow
		{
			// Szukanie nieprzejrzanego węzła położonego jak najbliżej poczatku scieżki
			current = 0;
			currentDistance = max;
			for (j = 0; j < numberOfCrossings; ++j)
			{
				if ((flags[j] == false) && (distance[j] <= currentDistance))
				{
					current = j;
					currentDistance = distance[j];
				}
			}
			
			//Przejrzenie polaczen do sasiadow
			foreach (Vector2 next in MyMap.FindConnectedCrossroads(crossingsTable[current]))
			{
				//Pobranie indeksu sąsiada
				neighbour = 0;
				for (j = 0; j < numberOfCrossings; ++j)
				{
					if ((crossingsTable[j] == next))
					{
						neighbour = j;
						break;
					}
				}
				
				//Wlasciwa czesc algorytmu
				float newDistance = currentDistance + MyMap.GetRoadLength(crossingsTable[current], next);
				if (distance[neighbour] > newDistance)
				{
					previousCrossing[neighbour] = current;
					distance[neighbour] = newDistance;
				}
			}
			
			flags[current] = true;
			
		}
		
		// Skladanie sciezki
		
		List<Vector2> path = new List<Vector2>();
		current = 0;
		for (i = 0; i < numberOfCrossings; ++i) // Szukanie indeksu wezla koncowego
		{
			flags[i] = false; // Flaga przyda sie podczas skladania sciezki
			if ((crossingsTable[i] == end))
				current = i;
		}
		
		path.Add(crossingsTable[current]);
		
		try
		{
			while ((crossingsTable[current] != start))
			{
				if (flags[current]) // Blokada przed zapetleniem
				{
					throw new Exception();
				};
				
				flags[current] = true;
				
				current = previousCrossing[current];
				path.Insert(0, crossingsTable[current]);
			}
		}
		catch (Exception)
		{
			Console.WriteLine("Brak polaczenia!");
		}
		return path;
	}
	
	// Konstruktor
	public Gps()
	{
	}
}
